using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;

using Windows.UI.Xaml.Shapes;
using System.Collections.ObjectModel;


// TODO remove if the app is ever finished
using System.Diagnostics;


namespace ITstudy.RedProjects
{
    /// <summary>
    /// Tower of Hanoi game.
    /// </summary>
    public sealed partial class TowerOfHanoi : Page
    {
        private struct TowerBlock
        {
            /// <summary>
            /// The width of this block as a whole number, ie 1-based index
            /// </summary>
            public int Width;
            /// <summary>
            /// The state of this block, eg Empty, Block, etc
            /// </summary>
            public BlockState State;

            public TowerBlock(int width = 0, BlockState state = BlockState.Empty)
            {
                Width = width;
                State = state;
            }
        }


        // General Project info, to be displayed under PivotItem "Project Details"
        // Total time spent on this project
        string ProjectTimeSpent = "56:00";
        // Difficulty, general challenge when writing on a scale of 0 to 10, 0 being no effort and 10 being near impossible to completed with my current skill
        string ProjectChallenge = "8";
        // Date when this project was finished
        string ProjectDateFinished = "29/06/21";


        // Tower height values (max ui-elements is 10)
        int[] TowerHeights = new int[] { 4, 5, 6, 7, 8, 9, 10 };
        int TowerHeight;
        public int TowerHeightDefault;
        public int TowerHeightMinimum;
        public int TowerHeightMaximum;

        // Tower block base values
        double TowerBlockHeight = 40;
        double TowerBlockWidthMinimum = 80;
        double TowerBlockWidthStep;


        // Gameboard block positions
        enum BlockState { Empty, Available, Block, Selected };
        TowerBlock[,] Gameboard;
        int[] SelectedBlock = new int[2];
        double[] BlockWidths;

        // The moves required to solve the tower, generated by the computer
        int[,] SolutionMoves;
        int SolutionCurrentMove = 0;
        // Starting and end state of generated solution
        TowerBlock[,] StartBoard;
        TowerBlock[,] EndBoard;

        // Tower blocks, UI-elements (have an inverse index relative to Gameboard)
        public ObservableCollection<TowerOfHanoiBlock> Tower0;
        public ObservableCollection<TowerOfHanoiBlock> Tower1;
        public ObservableCollection<TowerOfHanoiBlock> Tower2;


        // Tower block colours, create a number of block-colours, used to better distinguish between blocks with adjacent/similar sizes
        Windows.UI.Color[] BlockColours = new Windows.UI.Color[]
        {
            // Chocolate, #FFD2691E
            Windows.UI.Colors.Chocolate,
            // CadetBlue, #FF5F9EA0
            Windows.UI.Colors.CadetBlue,
            // OliveDrab, #FF6B8E23
            Windows.UI.Colors.OliveDrab,
            // DarkKhaki, #FFBDB76B
            Windows.UI.Colors.DarkKhaki
        };






        public TowerOfHanoi()
        {
            this.InitializeComponent();
            FinishSetup();
        }




        private void FinishSetup()
        {
            // Set the TowerHeight default, min and max 
            TowerHeightDefault = TowerHeights.ElementAt(TowerHeights.Length - 3);
            TowerHeightMinimum = TowerHeights.First();
            TowerHeightMaximum = TowerHeights.Last();
        }


        // Start a new game
        private void NewGame(int towerHeight = -1)
        {
            // Hide the win message
            WinTextBlock.Opacity = 0;

            // Disable the SolutionStep Buttons, can only be used after GenerateSolution() is called
            SolutionStepFirstButton.IsEnabled = false;
            SolutionStepBackButton.IsEnabled = false;
            SolutionStepForwardButton.IsEnabled = false;
            SolutionStepLastButton.IsEnabled = false;

            // Ensure a reasonable tower height
            if (towerHeight < TowerHeightMinimum || towerHeight > TowerHeightMaximum)
            {
                towerHeight = TowerHeightDefault;
            }

            // Set TowerHeight a class-scope variable, to be available to other methods
            TowerHeight = towerHeight;

            // Set the starting state of Gameboard
            Gameboard = new TowerBlock[3, towerHeight];
            for (int level = 0; level < Gameboard.GetLength(1); level++)
            {
                // Set the tower on the first column
                Gameboard[0, level] = new TowerBlock(level + 1, BlockState.Block);

                // Set all other elements to 0
                Gameboard[1, level] = new TowerBlock(0, BlockState.Empty);
                Gameboard[2, level] = new TowerBlock(0, BlockState.Empty);

                // Debug.WriteLine(string.Format("TowerOfHanoi: {0} {1} {2}", Gameboard[0, level].Width, Gameboard[1, level].Width, Gameboard[2, level].Width));
            }

            // Build the on-screen towers
            BuildTowers(Gameboard);

            // Set the top block of the first tower as Clickable
            SetBlockIsClickable(0, 0, true);

            // Allow the user to let the tower be solve by the computer
            SolveButton.IsEnabled = true;
        }


        /// <summary>
        /// Build towers based on the given (Game)board, TowerBlock-array
        /// </summary>
        /// <param name="board">The board to build</param>
        private void BuildTowers(TowerBlock[,] board)
        {
            if (board.GetLength(0) != 3 || board.GetLength(1) > TowerHeightMaximum)
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: BuildTowers() recieved array with invalid dimensions, {0}x{1}", board.GetLength(0), board.GetLength(1)));
                return;
            }

            // Generate new content the on-screen towers and their blocks
            double widthMax = GameboardGrid.ActualWidth / 3 - 20;
            TowerBlockWidthStep = (widthMax - TowerBlockWidthMinimum) / board.GetLength(1);

            BlockWidths = new double[board.GetLength(1)];

            Tower0 = new ObservableCollection<TowerOfHanoiBlock>();
            Tower1 = new ObservableCollection<TowerOfHanoiBlock>();
            Tower2 = new ObservableCollection<TowerOfHanoiBlock>();

            // Populate the Tower collections, done in reverse because the UI elements that use them are themselves rotated 180
            for (int iBlock = board.GetLength(1) - 1; iBlock > -1; iBlock--)
            {
                // Create the base elements
                Tower0.Add(new TowerOfHanoiBlock("0" + iBlock.ToString(), TowerBlockHeight, widthMax, board[0, iBlock].Width));
                Tower1.Add(new TowerOfHanoiBlock("1" + iBlock.ToString(), TowerBlockHeight, widthMax, board[1, iBlock].Width));
                Tower2.Add(new TowerOfHanoiBlock("2" + iBlock.ToString(), TowerBlockHeight, widthMax, board[2, iBlock].Width));

                // Store the 'base' block widths
                BlockWidths[iBlock] = TowerBlockWidthMinimum + iBlock * TowerBlockWidthStep;

                // Fill the towers based on the info in board
                // Tower 0
                switch (board[0, iBlock].State)
                {
                    case BlockState.Empty:
                        {
                            // Default state upon construction
                            break;
                        }
                    case BlockState.Available:
                        {
                            Tower0.Last().SetStateAvailable(BlockWidths[iBlock]);
                            break;
                        }
                    case BlockState.Block:
                        {
                            Tower0.Last().SetStateBlock(TowerBlockWidthMinimum + iBlock * TowerBlockWidthStep, BlockColours.ElementAt((iBlock + BlockColours.Length) % BlockColours.Length));
                            break;
                        }
                    case BlockState.Selected:
                        {
                            Tower0.Last().SetStateBlock(TowerBlockWidthMinimum + iBlock * TowerBlockWidthStep, BlockColours.ElementAt((iBlock + BlockColours.Length) % BlockColours.Length));
                            Tower0.Last().SetStateSelected();
                            break;
                        }
                }
                // Tower 1
                switch (board[1, iBlock].State)
                {
                    case BlockState.Empty:
                        {
                            // Default state upon construction
                            break;
                        }
                    case BlockState.Available:
                        {
                            Tower1.Last().SetStateAvailable(BlockWidths[iBlock]);
                            break;
                        }
                    case BlockState.Block:
                        {
                            Tower1.Last().SetStateBlock(TowerBlockWidthMinimum + iBlock * TowerBlockWidthStep, BlockColours.ElementAt((iBlock + BlockColours.Length) % BlockColours.Length));
                            break;
                        }
                    case BlockState.Selected:
                        {
                            Tower1.Last().SetStateBlock(TowerBlockWidthMinimum + iBlock * TowerBlockWidthStep, BlockColours.ElementAt((iBlock + BlockColours.Length) % BlockColours.Length));
                            Tower1.Last().SetStateSelected();
                            break;
                        }
                }
                // Tower 2
                switch (board[2, iBlock].State)
                {
                    case BlockState.Empty:
                        {
                            // Default state upon construction
                            break;
                        }
                    case BlockState.Available:
                        {
                            Tower2.Last().SetStateAvailable(BlockWidths[iBlock]);
                            break;
                        }
                    case BlockState.Block:
                        {
                            Tower2.Last().SetStateBlock(TowerBlockWidthMinimum + iBlock * TowerBlockWidthStep, BlockColours.ElementAt((iBlock + BlockColours.Length) % BlockColours.Length));
                            break;
                        }
                    case BlockState.Selected:
                        {
                            Tower2.Last().SetStateBlock(TowerBlockWidthMinimum + iBlock * TowerBlockWidthStep, BlockColours.ElementAt((iBlock + BlockColours.Length) % BlockColours.Length));
                            Tower2.Last().SetStateSelected();
                            break;
                        }
                }

            }

            // Set the top block of the first tower as Clickable
            // Tower0.Last().IsClickable = true;

            // Set the on-screen towers to the generated collections
            ReloadTower();

        }



        /// <summary>
        /// Automatically solve the current tower, resulting in the array SolutionMoves being filled with the required moves, which the user can then step through
        /// </summary>
        private void GenerateSolution()
        {
            // https://en.wikipedia.org/wiki/Tower_of_Hanoi, look under section Solution, there are also many more examples, explanations and solutions online

            // Ensure the Gameboard is in a 'clean' state, ie no blocks are in BlockState Available or Selected
            NewGame(TowerHeight);

            // Unable any user input on the gameboard (comment this out, as well as the enabling of SolutionStep buttons, if you would like to follow the steps manually)
            SetBlockIsClickable(0, 0, false);

            // Copy the starting and end state of the Gameboard for future reference
            StartBoard = new TowerBlock[Gameboard.GetLength(0), Gameboard.GetLength(1)];
            EndBoard = new TowerBlock[Gameboard.GetLength(0), Gameboard.GetLength(1)];
            for (int bl = 0; bl < EndBoard.GetLength(1); bl++)
            {
                StartBoard[0, bl] = Gameboard[0, bl];
                StartBoard[1, bl] = new TowerBlock();
                StartBoard[2, bl] = new TowerBlock();

                EndBoard[0, bl] = new TowerBlock();
                EndBoard[1, bl] = new TowerBlock();
                EndBoard[2, bl] = Gameboard[0, bl];
            }

            // Create the array that will contain all required moves, and set the index counter to 0
            SolutionMoves = new int[(int)(Math.Pow(2, TowerHeight) - 1), 4];
            SolutionCurrentMove = 0;

            // Create three Stack<int>'s, one for each of the towers, filled with the block widths on the Gameboard
            Stack<int> tower0 = new Stack<int>();
            Stack<int> tower1 = new Stack<int>();
            Stack<int> tower2 = new Stack<int>();
            for (int level = (Gameboard.GetLength(1) - 1); level > -1; level--)
            {
                if (Gameboard[0, level].State == BlockState.Block) { tower0.Push(Gameboard[0, level].Width); }
                if (Gameboard[1, level].State == BlockState.Block) { tower1.Push(Gameboard[0, level].Width); }
                if (Gameboard[2, level].State == BlockState.Block) { tower2.Push(Gameboard[0, level].Width); }
            }

            // Generate the solution
            SolveRecursively(TowerHeight, tower0, 0, tower2, 2, tower1, 1);

            Debug.WriteLine($"TowerOfHanoi: GenerateSolution() checking, SolutionMoves.Length == {SolutionMoves.GetLength(0)}, SolutionCurrentMove == {SolutionCurrentMove}");

            // Enable the step-through buttons
            SolutionStepFirstButton.IsEnabled = true;
            SolutionStepBackButton.IsEnabled = true;
            SolutionStepForwardButton.IsEnabled = true;
            SolutionStepLastButton.IsEnabled = true;

            // Reset solutionCurrentMove to 0, so it can be used to step through the generated solution
            SolutionCurrentMove = 0;

            // Display the current step and total number of steps found on screen
            SolutionCurrentStepTextBlock.Text = SolutionCurrentMove.ToString();
            SolutionTotalStepsTextBlock.Text = SolutionMoves.GetLength(0).ToString();
        }


        /// <summary>
        /// Fill SolutionMoves with the move required to solve the tower
        /// </summary>
        /// <param name="towerHeight">The height of the current tower</param>
        /// <param name="fromTower">The tower from which a block will be moved</param>
        /// <param name="fromTowerNumber">The number of the fromTower. 0, 1 or 2</param>
        /// <param name="toTower">The tower from which a block will be moved</param>
        /// <param name="toTowerNumber">The number of the toTower. 0, 1 or 2</param>
        /// <param name="otherTower">The other tower in play</param>
        /// <param name="otherTowerNumber">The number of the otherTower. 0, 1 or 2</param>
        private void SolveRecursively(int towerHeight, Stack<int> fromTower, int fromTowerNumber, Stack<int> toTower, int toTowerNumber, Stack<int> otherTower, int otherTowerNumber)
        {
            /* Solution examples
             * https://stackoverflow.com/questions/35298789/solving-towers-of-hanoi-in-c-sharp-using-recursion
             * https://www.csharpstar.com/towers-of-hanoi-in-csharp/
             * https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/
             */

            Debug.WriteLine($"TowerOfHanoi: SolveRecursively() called with {towerHeight}, from = tower {fromTowerNumber} with {fromTower.Count}, to = tower {toTowerNumber} with {toTower.Count}, other = tower {otherTowerNumber} with {otherTower.Count}");

            // If the current block is not the last block on the (starting) tower
            if (towerHeight > 0)
            {
                // Move the block above this one to otherTower
                SolveRecursively(towerHeight - 1, fromTower, fromTowerNumber, otherTower, otherTowerNumber, toTower, toTowerNumber);

                // Log the move for which this instance of SolveRecursively() was called
                LogSolutionMove(fromTowerNumber, TowerHeight - fromTower.Count, toTowerNumber, TowerHeight - (toTower.Count + 1), towerHeight);

                // Move the block on the tower Stacks
                toTower.Push(fromTower.Pop());

                // Move the newly placed block from otherTower to toTower
                SolveRecursively(towerHeight - 1, otherTower, otherTowerNumber, toTower, toTowerNumber, fromTower, fromTowerNumber);
            }
            else
            {
                Debug.WriteLine($"TowerOfHanoi: SolveRecursively() ended with towerHeight = {towerHeight}");
            }
        }


        /// <summary>
        /// Add the given move to SolutionMoves
        /// </summary>
        /// <param name="startTower">The starting tower</param>
        /// <param name="startBlock">The starting block</param>
        /// <param name="endTower">The destination tower</param>
        /// <param name="endBlock">The destination block</param>
        /// <param name="towerHeight">Height of the tower, only relevant for debug statements, can be ignored</param>
        private void LogSolutionMove(int startTower, int startBlock, int endTower, int endBlock, int towerHeight = -1)
        {
            SolutionMoves[SolutionCurrentMove, 0] = startTower;
            SolutionMoves[SolutionCurrentMove, 1] = startBlock;
            SolutionMoves[SolutionCurrentMove, 2] = endTower;
            SolutionMoves[SolutionCurrentMove, 3] = endBlock;
            Debug.WriteLine($"TowerOfHanoi: SolveRecursively() towerHeight = {towerHeight}, current move = {SolutionCurrentMove}, move made = {SolutionMoves[SolutionCurrentMove, 0]}{SolutionMoves[SolutionCurrentMove, 1]} to {SolutionMoves[SolutionCurrentMove, 2]}{SolutionMoves[SolutionCurrentMove, 3]}");
            SolutionCurrentMove++;
        }


        private void AnalyseInput(int tower, int level)
        {
            // Make sure the input is reasonable, not out-of-bounds
            if (tower < 0 || tower > 2 || level < 0 || level > TowerHeight)
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: AnalyseInput() recieved an out-of-bounds value. tower = {0}, level = {1}", tower, level));
                return;
            }

            // Act based on the state of the selected block
            switch (Gameboard[tower, level].State)
            {
                // If the block was empty, ignore
                case BlockState.Empty:
                    {
                        break;
                    }
                // If the block state is Available, it was flagged as a valid move for the previously selected block, so move the block to the new position
                case BlockState.Available:
                    {
                        if (Gameboard[SelectedBlock[0], SelectedBlock[1]].State == BlockState.Selected)
                        {
                            // Move the previously selected block to the new position
                            MoveBlock(SelectedBlock[0], SelectedBlock[1], tower, level);
                            // Set the new top block of startTower to clickable
                            SetBlockIsClickable(SelectedBlock[0], SelectedBlock[1] + 1, true);
                            // Set the block beneath the newly placed block to not clickable
                            SetBlockIsClickable(tower, level + 1, false);
                            // Check if the game has been won
                            CheckForWinState();
                        }
                        else
                        {
                            Debug.WriteLine(string.Format("TowerOfHanoi: AnalyseInput() wants to call MoveBlock() but no SelectedBlock was found"));
                            return;
                        }
                        break;
                    }
                // If the block state is Block, it is a newly selected block
                case BlockState.Block:
                    {
                        NewBlockSelected(tower, level);
                        break;
                    }
                // If the block was already selected, unselect the block
                case BlockState.Selected:
                    {
                        NewBlockSelected(-(tower + 1), level);
                        break;
                    }
            }

        }


        // Mark the newly selected block on screen, and un-mark any blocks previously selected, and find the positions of all possible moves
        // Can also clear a selected block by giving a negative, 1-based, value for tower
        private void NewBlockSelected(int tower, int level)
        {
            // Make sure level in within bounds
            if (tower < -3 || tower > 2 || level < 0 || level > (TowerHeight - 1))
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: NewBlockSelected() recieved invalid value. tower = {0}, level = {1}", tower, level));
                return;
            }

            // If tower was negative, unselect the block and return
            if (tower < 0)
            {
                // Unselect the block
                Gameboard[(tower + 1) * -1, level].State = BlockState.Block;
                UpdateBlock((tower + 1) * -1, level);
                // Hide any borders from previous possible moves
                if (tower != -1)
                {
                    HideBorder(0, GetLowestEmptyBlock(0));
                }
                if (tower != -2)
                {
                    HideBorder(1, GetLowestEmptyBlock(1));
                }
                if (tower != -3)
                {
                    HideBorder(2, GetLowestEmptyBlock(2));
                }
                return;
            }
            // Else set SelectedBlock to the currently selected block and continue
            else
            {
                SelectedBlock[0] = tower; SelectedBlock[1] = level;
                Gameboard[tower, level].State = BlockState.Selected;
                UpdateBlock(tower, level);
            }

            int x = 0;

            // Find and show all possible moves
            if (tower != 0)
            {
                x = GetLowestEmptyBlock(0);
                if (x > -1 && IsMoveAllowed(Gameboard[tower, level].Width, 0, x))
                {
                    Gameboard[0, x].State = BlockState.Available;
                    UpdateBlock(0, x);
                }
            }
            if (tower != 1)
            {
                x = GetLowestEmptyBlock(1);
                if (x > -1 && IsMoveAllowed(Gameboard[tower, level].Width, 1, x))
                {
                    Gameboard[1, x].State = BlockState.Available;
                    UpdateBlock(1, x);
                }
            }
            if (tower != 2)
            {
                x = GetLowestEmptyBlock(2);
                if (x > -1 && IsMoveAllowed(Gameboard[tower, level].Width, 2, x))
                {
                    Gameboard[2, x].State = BlockState.Available;
                    UpdateBlock(2, x);
                }
            }
                        
        }



        /// <summary>
        /// Move a block from one position to another
        /// </summary>
        /// <param name="startTower">The original tower</param>
        /// <param name="startLevel">The original level</param>
        /// <param name="endTower">The destination tower</param>
        /// <param name="endLevel">The destination level</param>
        private void MoveBlock(int startTower, int startLevel, int endTower, int endLevel)
        {
            if (startTower < 0 || startTower > 2)
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: MoveBlock() recieved invalid input for startTower; {0}", startTower));
                return;
            }
            else if (startLevel < 0 || startLevel >= TowerHeight)
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: MoveBlock() recieved invalid input for startLevel; {0}", startLevel));
                return;
            }
            else if (endTower < 0 || endTower > 2)
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: MoveBlock() recieved invalid input for endTower; {0}", endTower));
                return;
            }
            else if (endLevel < 0 || endLevel >= TowerHeight)
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: MoveBlock() recieved invalid input for endLevel; {0}", endLevel));
                return;
            }

            // Change the cells in Gameboard
            Gameboard[endTower, endLevel].Width = Gameboard[startTower, startLevel].Width;
            Gameboard[endTower, endLevel].State = BlockState.Block;
            Gameboard[startTower, startLevel].Width = 0;
            Gameboard[startTower, startLevel].State = BlockState.Empty;

            // Change the on-screen representation of the blocks
            UpdateBlock(startTower, startLevel);
            UpdateBlock(endTower, endLevel);

            // Unset the other border if present
            int x = -1;
            int y = -1;
            if (startTower == 0) { x = (endTower == 1) ? 2 : 1; }
            else if (startTower == 1) { x = (endTower == 2) ? 0 : 2; }
            else { x = (endTower == 0) ? 1 : 0; }
            y = GetLowestEmptyBlock(x);
            if (y > -1)
            {
                Gameboard[x, y].State = BlockState.Empty;
                UpdateBlock(x, y);
            }

        }


        private void CheckForWinState()
        {
            // If the highest possible position in the tower on the right contains a block, the game is won
            if (Gameboard[2, 0].State == BlockState.Block)
            {
                // Make this block not-clickable
                Tower2.Last().IsClickable = false;
                ReloadTower(2);

                // Display the win message
                WinTextBlock.Opacity = 1;
            }
        }


        /// <summary>
        /// Get the level of highest block of a speficied tower
        /// Can be out of range! Happens when no block was found
        /// </summary>
        /// <param name="tower">The tower to look at</param>
        /// <returns>The level of the highest block in this tower, -1 if no block was found</returns>
        private int GetHighestBlock(int tower)
        {
            int highestLevel = -1;

            for (int level = (Gameboard.GetLength(1) - 1); level > -1; level--)
            {
                // Find the first block with state Empty
                if (Gameboard[tower, level].State == BlockState.Empty)
                {
                    // Make sure we did not hit on the first block, which means there are blocks in the tower
                    if (level != (Gameboard.GetLength(1) - 1))
                    {
                        highestLevel = level + 1;
                    }
                    break;
                }
            }

            return highestLevel;
        }


        /// <summary>
        /// Get the level of the lowest empty, or available, block of a specified tower
        /// Can be out of range! Happens when no empty block was found
        /// </summary>
        /// <param name="tower">The tower to look at</param>
        /// <returns>The level of the lowest empty block in the tower, -1 if no block was found</returns>
        private int GetLowestEmptyBlock(int tower)
        {
            int lowestEmpty = -1;

            for (int level = (Gameboard.GetLength(1) - 1); level > -1; level--)
            {
                if (Gameboard[tower, level].State == BlockState.Empty || Gameboard[tower, level].State == BlockState.Available)
                {
                    lowestEmpty = level;
                    break;
                }
            }

            return lowestEmpty;
        }


        /// <summary>
        /// Get whether or not a move is allowed. Checks the position below the desired one to see if there is a block there, and if it is larger than the one we want to place on it.
        /// </summary>
        /// <param name="blockWidth">The width of the block we want to move</param>
        /// <param name="tower">The tower we want to move to</param>
        /// <param name="level">The level we want to move to</param>
        /// <returns>True or false; is the desired move is allowed or not.</returns>
        private bool IsMoveAllowed(int blockWidth, int tower, int level)
        {
            // If the desired position is at the bottom, always allowed
            if (level == Gameboard.GetLength(1) - 1) { return true; }
            // Else find out if the block underneath is larger
            else
            {
                return (blockWidth < Gameboard[tower, level + 1].Width);
            }
        }


        /// <summary>
        /// Set whether a specific block is clickable or not
        /// </summary>
        /// <param name="tower">The tower of the block</param>
        /// <param name="level">THe level of the block</param>
        /// <param name="isClickable">What to set Clickable to</param>
        private void SetBlockIsClickable(int tower, int level, bool isClickable)
        {
            if (level > -1 && level < TowerHeight)
            {
                switch (tower)
                {
                    case 0:
                        {
                            Tower0.ElementAt((TowerHeight - 1) - level).IsClickable = isClickable;
                            break;
                        }
                    case 1:
                        {
                            Tower1.ElementAt((TowerHeight - 1) - level).IsClickable = isClickable;
                            break;
                        }
                    case 2:
                        {
                            Tower2.ElementAt((TowerHeight - 1) - level).IsClickable = isClickable;
                            break;
                        }
                }
                ReloadTower(tower);
            }
            
        }


        /// <summary>
        /// Hide any border at the given position
        /// </summary>
        /// <param name="tower"></param>
        /// <param name="level"></param>
        private void HideBorder(int tower, int level)
        {
            if (level > -1 && level < TowerHeight)
            {
                switch (tower)
                {
                    case 0:
                        {
                            Tower0.ElementAt((TowerHeight - 1) - level).HideBorder();
                            break;
                        }
                    case 1:
                        {
                            Tower1.ElementAt((TowerHeight - 1) - level).HideBorder();
                            break;
                        }
                    case 2:
                        {
                            Tower2.ElementAt((TowerHeight - 1) - level).HideBorder();
                            break;
                        }
                }
                ReloadTower(tower);
            }
        }


        /// <summary>
        /// Update a single block in the tower collections on-screen, to its state in Gameboard
        /// </summary>
        /// <param name="tower">The tower where the block is located at</param>
        /// <param name="level">The level where the block is located at</param>
        private void UpdateBlock(int tower, int level)
        {
            if (tower < 0 || tower > 2 || level < 0 || level > TowerHeight - 1)
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: UpdateBlock() revieced invalid input. tower={0}, level={1}", tower, level));
                return;
            }

            TowerBlock newBlock = Gameboard[tower, level];

            switch (newBlock.State)
            {
                case BlockState.Empty:
                    {
                        switch (tower)
                        {
                            case 0:
                                {
                                    Tower0.ElementAt((TowerHeight - 1) - level).SetStateEmpty();
                                    break;
                                }
                            case 1:
                                {
                                    Tower1.ElementAt((TowerHeight - 1) - level).SetStateEmpty();
                                    break;
                                }
                            case 2:
                                {
                                    Tower2.ElementAt((TowerHeight - 1) - level).SetStateEmpty();
                                    break;
                                }
                        }
                        break;
                    }

                case BlockState.Available:
                    {
                        switch (tower)
                        {
                            case 0:
                                {
                                    Tower0.ElementAt((TowerHeight - 1) - level).SetStateAvailable(BlockWidths[Gameboard[SelectedBlock[0], SelectedBlock[1]].Width - 1]);
                                    break;
                                }
                            case 1:
                                {
                                    Tower1.ElementAt((TowerHeight - 1) - level).SetStateAvailable(BlockWidths[Gameboard[SelectedBlock[0], SelectedBlock[1]].Width - 1]);
                                    break;
                                }
                            case 2:
                                {
                                    Tower2.ElementAt((TowerHeight - 1) - level).SetStateAvailable(BlockWidths[Gameboard[SelectedBlock[0], SelectedBlock[1]].Width - 1]);
                                    break;
                                }
                        }
                        break;
                    }

                case BlockState.Block:
                    {
                        switch (tower)
                        {
                            case 0:
                                {
                                    Tower0.ElementAt((TowerHeight - 1) - level).SetStateBlock(BlockWidths[newBlock.Width - 1], BlockColours.ElementAt((newBlock.Width - 1 + BlockColours.Length) % BlockColours.Length));
                                    break;
                                }
                            case 1:
                                {
                                    Tower1.ElementAt((TowerHeight - 1) - level).SetStateBlock(BlockWidths[newBlock.Width - 1], BlockColours.ElementAt((newBlock.Width - 1 + BlockColours.Length) % BlockColours.Length));
                                    break;
                                }
                            case 2:
                                {
                                    Tower2.ElementAt((TowerHeight - 1) - level).SetStateBlock(BlockWidths[newBlock.Width - 1], BlockColours.ElementAt((newBlock.Width - 1 + BlockColours.Length) % BlockColours.Length));
                                    break;
                                }
                        }
                        break;
                    }

                case BlockState.Selected:
                    {
                        // unset any previously possible moves
                        int x = GetLowestEmptyBlock(0);
                        if (x > -1) { Tower0.ElementAt((TowerHeight - 1) - x).SetStateEmpty(); }
                        x = GetLowestEmptyBlock(1);
                        if (x > -1) { Tower1.ElementAt((TowerHeight - 1) - x).SetStateEmpty(); }
                        x = GetLowestEmptyBlock(2);
                        if (x > -1) { Tower2.ElementAt((TowerHeight - 1) - x).SetStateEmpty(); }

                        switch (tower)
                        {
                            case 0:
                                {
                                    Tower0.ElementAt((TowerHeight - 1) - level).SetStateSelected();
                                    break;
                                }
                            case 1:
                                {
                                    Tower1.ElementAt((TowerHeight - 1) - level).SetStateSelected();
                                    break;
                                }
                            case 2:
                                {
                                    Tower2.ElementAt((TowerHeight - 1) - level).SetStateSelected();
                                    break;
                                }
                        }
                        break;
                    }

                default:
                    {
                        Debug.WriteLine(string.Format("TowerOfHanoi: ChangeBlock() did not recognise the given state, {0}", newBlock.State));
                        break;
                    }

            }

            ReloadTower(tower);

        }



        // Reload the any or all of the on-screen towers
        private void ReloadTower(int tower = -1)
        {
            switch (tower)
            {
                case 0:
                    {
                        GameboardTower0GridView.ItemsSource = null;
                        GameboardTower0GridView.ItemsSource = Tower0;
                        break;
                    }
                case 1:
                    {
                        GameboardTower1GridView.ItemsSource = null;
                        GameboardTower1GridView.ItemsSource = Tower1;
                        break;
                    }
                case 2:
                    {
                        GameboardTower2GridView.ItemsSource = null;
                        GameboardTower2GridView.ItemsSource = Tower2;
                        break;
                    }
                default:
                    {
                        GameboardTower0GridView.ItemsSource = null;
                        GameboardTower0GridView.ItemsSource = Tower0;
                        GameboardTower1GridView.ItemsSource = null;
                        GameboardTower1GridView.ItemsSource = Tower1;
                        GameboardTower2GridView.ItemsSource = null;
                        GameboardTower2GridView.ItemsSource = Tower2;
                        break;
                    }
            }
        }









        // Get to desired TowerHeigth from the ContentDialog, and send it to NewGame()
        private async void NewGameButton_Click(object sender, RoutedEventArgs e)
        {
            // Show the dialog to start a new game
            ContentDialogResult result = await NewGameContentDialog.ShowAsync();

            // If the selected button, result, was the one for a new game
            if (result == ContentDialogResult.Primary)
            {
                NewGame((int)TowerHeightNumberBox.Value);
            }
            // Else the button was "cancel"
        }

        private void SolveButton_Click(object sender, RoutedEventArgs e)
        {
            GenerateSolution();
        }

        // Lets the user step through the solution of a tower
        private void SolutionStepButtons_Click(object sender, RoutedEventArgs e)
        {
            // Get the tag from sender
            string tag = ((Button)sender).Tag.ToString();
            // Act based on the content of the tag
            switch (tag)
            {
                case "--":
                    {
                        Debug.WriteLine($"TowerOfHanoi: SolutionStepButton Start");
                        SolutionCurrentMove = 0;
                        BuildTowers(StartBoard);
                        break;
                    }
                case "-":
                    {
                        Debug.WriteLine($"TowerOfHanoi: SolutionStepButton Backward");
                        if (SolutionCurrentMove > 0)
                        {
                            SolutionCurrentMove--;
                            MoveBlock(SolutionMoves[SolutionCurrentMove, 2], SolutionMoves[SolutionCurrentMove, 3], SolutionMoves[SolutionCurrentMove, 0], SolutionMoves[SolutionCurrentMove, 1]);
                        }                        
                        break;
                    }
                case "+":
                    {
                        Debug.WriteLine($"TowerOfHanoi: SolutionStepButton Forward");
                        if (SolutionCurrentMove < SolutionMoves.GetLength(0))
                        {
                            MoveBlock(SolutionMoves[SolutionCurrentMove, 0], SolutionMoves[SolutionCurrentMove, 1], SolutionMoves[SolutionCurrentMove, 2], SolutionMoves[SolutionCurrentMove, 3]);
                            SolutionCurrentMove++;
                        }                        
                        break;
                    }
                case "++":
                    {
                        Debug.WriteLine($"TowerOfHanoi: SolutionStepButton End");
                        SolutionCurrentMove = SolutionMoves.GetLength(0);
                        BuildTowers(EndBoard);
                        break;
                    }
            }
            // Update the current step number on screen
            SolutionCurrentStepTextBlock.Text = SolutionCurrentMove.ToString();
        }


        private void TowerBlockButton_Click(object sender, RoutedEventArgs e)
        {
            Button button = sender as Button;
            /*
            try
            {
                button = sender as Button;
            }
            catch (Exception ex)
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: TowerBlockButton_Click failed to convert event sender to a Button. {0}", ex));
                return;
            }
            */
            
            string b = button.Name;
            // Debug.WriteLine(string.Format("TowerOfHanoi: Towerblock clicked = {0}", b));

            if (!char.IsDigit(b[0]) || !char.IsDigit(b[1]))
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: TowerBlockButton_Click() could not read a valid button name {0}", b));
                return;
            }
            else
            {
                AnalyseInput((int)char.GetNumericValue(b[0]), (int)char.GetNumericValue(b[1]));
            }

        }















        // Helper method, print the current widths of the elements in gameboard to Output
        private void PrintGameboardWidths()
        {
            Debug.WriteLine(string.Format("TowerOfHanoi: Current Gameboard values are;"));

            for (int i = 0; i < Gameboard.GetLength(1); i++)
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: {0} {1} {2}", Gameboard[0, i].Width, Gameboard[1, i].Width, Gameboard[2, i].Width));
            }
        }

        // Helper method, print the current states of the elements in gameboard to Output
        private void PrintGameboardStates()
        {
            Debug.WriteLine(string.Format("TowerOfHanoi: Current Gameboard states are;"));

            for (int i = 0; i < Gameboard.GetLength(1); i++)
            {
                Debug.WriteLine(string.Format("TowerOfHanoi: {0} {1} {2}", Gameboard[0, i].State, Gameboard[1, i].State, Gameboard[2, i].State));
            }
        }


    }
}

